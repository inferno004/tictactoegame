# -*- coding: utf-8 -*-
"""Another copy of Python programming - Tutorial.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xX9uyLyUqBEDPqbS3m5DfuvSmODk-BO0
"""

import ipywidgets as widgets
from IPython.display import display
import random

class TicTacToe:
    def __init__(self, size=3):
        self.size = size
        self.board = [['empty' for _ in range(size)] for _ in range(size)]
        self.players = ['üêù', 'üå∏', 'üçÑ']  # Emoji for bee, flower, and mushroom
        self.current_player = self.players[0]

    def print_board(self):
        for row in self.board:
            print("|".join(row))

    def check_winner(self):
        # Check rows
        for row in self.board:
            if row.count(row[0]) == len(row) and row[0] != 'empty':
                return True

        # Check columns
        for col in range(self.size):
            if all(self.board[row][col] == self.board[row + 1][col] != 'empty' for row in range(self.size - 1)):
                return True

        # Check diagonals
        if all(self.board[i][i] == self.board[i + 1][i + 1] != 'empty' for i in range(self.size - 1)):
            return True
        if all(self.board[i][self.size - 1 - i] == self.board[i + 1][self.size - 2 - i] != 'empty' for i in range(self.size - 1)):
            return True

        return False

    def is_board_full(self):
        return all(cell != 'empty' for row in self.board for cell in row)

    def click(self, button):
        if ',' in button.description:
            row, col = map(int, button.description.split(','))
            if self.board[row][col] == 'empty':
                button.description = self.current_player
                self.board[row][col] = self.current_player
                if self.check_winner():
                    print(f"Player {self.current_player} wins!")
                elif self.is_board_full():
                    print("It's a tie!")
                else:
                    index = self.players.index(self.current_player)
                    self.current_player = self.players[(index + 1) % len(self.players)]
        else:
            button.description = self.current_player
            # Find the corresponding row and column of the button in the grid
            for i in range(self.size):
                for j in range(self.size):
                    if button is self.buttons[i * self.size + j]:
                        row, col = i, j
                        break
            self.board[row][col] = self.current_player
            if self.check_winner():
                print(f"Player {self.current_player} wins!")
            elif self.is_board_full():
                print("It's a tie!")
            else:
                index = self.players.index(self.current_player)
                self.current_player = self.players[(index + 1) % len(self.players)]

    def scramble_board(self, _):
        symbols = [cell for row in self.board for cell in row if cell != 'empty']
        random.shuffle(symbols)
        for i in range(self.size):
            for j in range(self.size):
                if self.board[i][j] != 'empty':
                    self.board[i][j] = symbols.pop(0)
                    self.buttons[i * self.size + j].description = self.board[i][j]

def create_board(size=3):
    game = TicTacToe(size)
    buttons = []
    for i in range(size):
        for j in range(size):
            button = widgets.Button(description=f"{i},{j}", layout=widgets.Layout(width='50px', height='50px'))
            button.on_click(game.click)
            buttons.append(button)
    game.buttons = buttons  # Store the buttons in the game instance
    display(widgets.GridBox(buttons, layout=widgets.Layout(grid_template_columns=" ".join(["50px"]*size))))
    scramble_button = widgets.Button(description="Scramble Board", layout=widgets.Layout(width='auto', height='50px'))
    scramble_button.on_click(game.scramble_board)
    display(scramble_button)

size_selector = widgets.IntSlider(value=3, min=3, max=10, step=1, description='Board Size:')
display(size_selector)

def handle_size_change(change):
    create_board(change.new)

size_selector.observe(handle_size_change, names='value')